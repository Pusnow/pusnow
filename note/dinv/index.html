<!DOCTYPE html>
<html lang="ko-kr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>DinV (Docker-in-VM) | Pusnow</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav class="no-print">
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/about/">About</a></li>
      
    </ul>
    <hr/>
    </nav>

<h1>DinV (Docker-in-VM)</h1>


<span class="date">2022/01/31</span>

<span class="date">(Last update: 2022/10/24)</span>


<hr />
<main>
    <ul>
<li><a href="https://github.com/Pusnow/dinv">Source code available</a></li>
</ul>
<p>간혹 Docker를 Docker 컨테이너 안에서 실행시켜야 하는 경우가 있다.
특히, CI 서비스(<a href="https://plugins.jenkins.io/docker-plugin/">Jenkins Docker</a>, <a href="https://docs.github.com/en/actions/creating-actions/creating-a-docker-container-action">GitHub Docker Container Action</a>, <a href="https://docs.gitlab.com/runner/executors/docker.html">GitLab Docker executor</a>)를 Docker를 통하여 배포할 때, Docker 이미지를 빌드할 수 없는 문제가 생긴다.
이는 Docker 이미지를 빌드하기 위해 필요한 <code>dockerd</code> 데몬이 많은 시스템 권한을 요구하기 때문이다.</p>
<h2 id="기존-솔루션">기존 솔루션</h2>
<p>지금까지 <code>dockerd</code>를 컨테이너 안에서 실행시키기 위해서는 DooD (Docker-out-of-Docker) 혹은 <a href="https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">DinD (Docker-in-Docker)</a> 기법을 사용한다.
DooD 기법은 컨테이너 내부에서 호스트 <code>dockerd</code>에 연결하여 사용하는 기법으로, 이를 위해 도커 컨트롤 소켓(<code>/var/run/docker.sock</code>)을 bind mount 하여 사용한다.
이 기법은 컨테이너가 호스트 <code>dockerd</code>에 대한 거의 모든 접근 권한을 가지기 때문에, 컨테이너 isolation을 회피하여 다른 컨테이너에 영향을 줄 수 있다.
DinD 기법은 <code>dockerd</code>를 컨테이너 안에서 실행시키기 위해 privileged 컨테이너를 사용한다. Privileged 컨테이너는 일반 Docker 컨테이너와 달리, <a href="https://docs.docker.com/engine/reference/commandline/run/#full-container-capabilities---privileged">모든 권한</a>을 가져간다. 따라서, 호스트가 수행할 수 있는 모든 작업을 시행할 수 있다는 것을 의미한다.
따라서, DooD와 DinD 모두 실제 사용하기에는 보안 고려사항 때문에 쉽게 적용하기가 어렵다.</p>
<p><a href="https://github.com/nestybox/sysbox">Sysbox</a>는 이 문제를 해결하기 위해 등장했다. 이는 Docker 런타임과 호환되는 <code>runc</code> 구현체로, Linux user-namespace와 시스템 파티션(<code>/sys</code>, <code>/proc</code> 등)을 흉내 내는 OS shim으로 구성되어 있다. 이를 통해 <code>dockerd</code>를 privileged 권한 없이 실행할 수 있게 된다.
하지만, 이와 같은 솔루션은 호스트 측에 추가적인 런타임을 설치해야 하며, 따로 관리해주어야 하는 단점이 존재한다.</p>
<h2 id="virtualization-기법">Virtualization 기법</h2>
<p>기존 솔루션을 검토해본 결과 다음과 같은 조건을 모두 만족하는 솔루션은 없었다.</p>
<ul>
<li>최소한의 권한 사용 (unprivileged, <code>dockerd</code> isolation)</li>
<li>Docker 혹은 podman 런타임에서 실행 가능 (추가적인 host-side 런타임 설치 불필요)</li>
<li>CI 용으로 사용하므로 높은 성능은 불필요</li>
</ul>
<p>이 경우 VM 기술을 사용하면 모든 조건을 만족할 수 있다.
VM을 이용하여 host 측과 격리된 Linux를 실행하게 되면, host에 영향 없이 Linux의 모든 기능을 사용할 수 있어서, <code>dockerd</code>를 실행 할 수 있게 된다.
또한, VM을 사용하기 위해서는 <code>kvm</code> 디바이스 드라이버 권한만 필요하므로, 권한 부여를 최소화 할 수 있다.
비록 가상화 오버헤드 때문에 성능(특히 I/O)은 저하될 수 있는데, 이는 CI 환경이므로 큰 문제가 되지 않는다.</p>
<h2 id="dinv-docker-in-vm">DinV (Docker-in-VM)</h2>
<p>따라서, Docker를 이용해 쉽게 사용할 수 있는 DinV를 만들었다 (엄밀히는 Docker-in-VM-in-Docker).
DinV 컨테이너는 가벼운 <a href="https://qemu.readthedocs.io/en/latest/system/i386/microvm.html">QEMU microVM</a>을 실행하여, 가벼운 리눅스 가상 머신 (<a href="https://www.alpinelinux.org/">Alpine Linux</a> 기반)과 <code>dockerd</code>를 실행한다.
또한 <a href="https://wiki.qemu.org/Documentation/Networking#User_Networking_.28SLIRP.29">SLIRP</a>와 <a href="https://wiki.qemu.org/Documentation/9psetup">virtio-9p</a>를 이용하여 port binding과 bind mount를 제공한다.</p>
<h3 id="microvm">microVM</h3>
<p>QEMU microVM은 가벼운 가상 머신으로 작은 이미지 사이즈 및 빠른 부팅 속도와 같은 장점을 가지고 있다.
DinV에서는 microVM을 이용하여 VM 인스턴스를 제공한다<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<h3 id="slirp">SLIRP</h3>
<p>SLIRP(혹은 user networing)는 QEMU에서 제공하는 기본적인 네트워킹 방식이다.
TAP 네트워킹 방식과 비교하여 성능은 떨어지지만, port forwarding 기능을 쉽게 제공할 수 있고, <code>CAP_NET_ADMIN</code>과 같은 추가적인 권한을 요구하지 않기 때문에 DinV에서는 SLIRP를 사용한다.</p>
<p>단, 이 때문에, SLIRP가 가지는 몇 단점(낮은 성능 및 ICMP 미작동)을 가지게 된다.</p>
<h3 id="virtio-9p">virtio-9p</h3>
<p>Bind mount는 컨테이너와 호스트 간에 shared file system을 구성하는 기능이다.
하나의 커널을 사용하는 Docker 컨테이너와 달리, VM과 호스트 간 shared file system을 만드는 것은 조금 어려운 일이다.
이를 위해서 대부분의 기존 구현체(<a href="https://www.docker.com/products/docker-desktop">Docker for Desktop</a>, <a href="https://docs.podman.io/en/latest/markdown/podman-machine.1.html">Podman Machine</a>)는 대부분 <a href="https://github.com/libfuse/sshfs">SSHFS</a>를 사용하여 구성한다.
SSHFS는 추가적인 SSH 관리가 필요하고, 낮은 성능을 가지기 때문에 DinV에서는 사용하지 않고, 가상화를 이용한 기술을 검토하여 도입했다.</p>
<p>QEMU에서 지원하는 가상화 기반 shared file system은 두 가지가 존재한다: <a href="https://wiki.qemu.org/Documentation/9psetup">virtio-9p</a>, <a href="https://virtio-fs.gitlab.io">virtio-fs</a>.
대부분의 경우 virtio-fs 훨씬 높은 성능을 <a href="https://vmsplice.net/~stefan/virtio-fs_%20A%20Shared%20File%20System%20for%20Virtual%20Machines.pdf">보여주지만</a>, 아직 QEMU microVM에서는 이를 지원하지 못한다<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.
따라서 DinV에서는 virtio-9p를 이용하여 bind mount를 지원한다.</p>
<h2 id="사용법">사용법</h2>
<p>자세한 사용법은 <a href="https://github.com/Pusnow/dinv">GitHub repo</a>에서 확인 가능하다.</p>
<h2 id="자세한-기술적-내용">자세한 기술적 내용</h2>
<h3 id="graceful-shutdown">Graceful shutdown</h3>
<p>CI 워크플로에서는 큰 필요가 없을 수도 있지만, DinV는 graceful shutdown을 지원한다.
QEMU에서 graceful shutdown을 지원하는 것은 hard shutdown (<code>SIGINT</code>로 호출됨)과 달리 조금 노력이 필요하다.</p>
<p>QEMU에서 graceful shutdown을 수행하기 위해서는, 가장 먼저 guest-side에 shutdown 시그널을 보내야 한다.
이를 위해서 QEMU는 <a href="https://pve.proxmox.com/wiki/QEMU/KVM_ACPI_Guest_Shutdown">ACPI와 QEMU Guest Agent 두 가지 방법을 지원하는데</a>, DinV에서 사용하는 microVM은 ACPI 지원이 빠져 있으므로, DinV는 QEMU Guest Agent를 사용한다.
이를 위하여, DinV가 사용하는 VM 이미지는 QEMU Guest Agent 및 관련 커널 모듈(<code>virtio_console</code>)을 추가로 활성화한다.</p>
<p>Docker에서는 컨테이너를 shutdown 할 때 (<code>docker stop</code>), 기본적으로 <code>SIGTERM</code> 시그널을 사용하고 특정 시간이 지나면 <code>SIGKILL</code>을 사용한다.
DinV의 Docker entrypoint는 이와 같은 시그널을 처리하기 위하여 <code>SIGTERM</code> 핸들러를 설치하고, 이 핸들러에서는 QEMU Guest Agent 콘솔로 종료 명령을 전달한다.
이와 같은 방식으로, <code>docker stop</code> -&gt; <code>SIGTERM</code> -&gt; <code>Handler</code> -&gt; <code>Guest Agent</code> -&gt; <code>Shutdown</code> 순으로 graceful shutdown이 진행된다.</p>
<p>마지막으로, 조금 더 안전한 graceful shutdown을 위하여 DinV의 <a href="https://docs.docker.com/engine/reference/commandline/dockerd/"><code>shutdown-timeout</code></a>을 호스보다 낮은 값으로 설정하여 DinV의 <code>dockerd</code>가 종료되기 전에 컨테이너 shutdown timeout이 발생하여 <code>SIGKILL</code>로 강제 종료되는 상황을 방지하였다.</p>
<h3 id="port-forwarding">Port forwarding</h3>
<p>VM안에서 <code>dockerd</code>를 아무런 설정 없이 실행하면, port forwarding이 정상적으로 동작하지 않을 수 있다.
이는 host docker 네트워크와 컨테이너 네트워크 간 IP 충돌이 발생하기 때문이다. 두 네트워크 모두 <code>172.17.0.0/16</code> 대역(<code>dockerd</code> 기본 값)을 사용하므로 VM 안에서 <code>172.17.0.0/16</code> 대역을 조회할 때, routing이 host와 container network를 구분하지 못하기 때문이다.</p>
<p>따라서, DinV는 <code>dockerd</code>에 <code>--bip</code> (bridge IP) 옵션을 사용하여 container network의 IP 대역을 <code>172.19.0.0/16</code>으로 변경하여 해결하였다.
이렇게 해야만, host network와 container network를 구분이 가능하다.</p>
<pre tabindex="0"><code>┌host network──────────────┐
│172.17.0.0/16             │
│┌VM container────────────┐│
││IP: 172.17.0.3/16       ││
││┌container network─────┐││
│││172.19.0.0/16         │││
│││┌container───────────┐│││
││││IP: 172.19.0.3/16   ││││
│││└────────────────────┘│││
││└──────────────────────┘││
│└────────────────────────┘│
└──────────────────────────┘
</code></pre><div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>사실 DinV를 위해 꼭 microVM을 사용해야 하는 것은 아니다.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>QEMU microVM에서는 PCI를 에뮬레이션하지 않고 virtio-mmio기반 디바이스만 지원한다. virtio-fs를 사용하기 위해서는
vhost-user-fs 디바이스가 필요한데, 이 디바이스는 PCI만 지원하기 때문에 (<code>vhost-user-fs-pci</code>) microVM에서는 사용할 수 없다.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

</main>

  <footer class="no-print">
  
  
  <hr/>
  © <a href="https://www.pusnow.com">Wonsup Yoon</a> | <a href="https://github.com/pusnow">GitHub</a> | Original theme: <a href="https://github.com/yihui/hugo-xmin">Hugo xmin</a>
  
  </footer>
  </body>
</html>

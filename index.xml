<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pusnow</title>
    <link>https://www.pusnow.com/</link>
    <description>Recent content on Pusnow</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 17 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.pusnow.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS 분야 우수 학술대회 목록</title>
      <link>https://www.pusnow.com/note/cs-top-conferences/</link>
      <pubDate>Wed, 17 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/cs-top-conferences/</guid>
      <description>URL: https://gist.github.com/Pusnow/6eb933355b5cb8d31ef1abcb3c3e1206
과제 실적 정리 등으로 CS 분야 우수 학술대회 목록을 사용해야 할 때가 있다. 한국에서 자주 사용되는 목록으로는 한국정보과학회, BK21플러스, KAIST, 서울대, 포항공대에서 관리하는 목록이 있는데, 관련 목록을 쉽게 확인할 수 있도록 정리하였다.</description>
    </item>
    
    <item>
      <title>USE 방법론과 RED 방법론</title>
      <link>https://www.pusnow.com/note/use-method-and-red-method/</link>
      <pubDate>Wed, 06 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/use-method-and-red-method/</guid>
      <description>시스템의 성능을 분석하는 기법 중 USE 방법론(the USE method)과 RED 방법론(the RED method) 이 널리 알려져 있다. 본 글에서는 이 두 방법론을 간단하게 소개하고, 차이점과 장단점을 분석해 본다.
USE 방법론 (The USE Method) 시스템을 개발하고 관리하다 보면, 시스템이 종종 기대치에 못 미치는 성능을 보여주는 성능 이슈에 직면하게 된다. 복잡한 시스템에서는, 왜 혹은 시스템의 어떤 부분이 이러한 성능 이슈를 발생시키는지를 찾기는 조금 어려울 수 있다.
USE 방법론은 성능 이슈를 빠르게 해결하기 위하여 Brendan Gregg가 고안한 방법이다.</description>
    </item>
    
    <item>
      <title>DinV (Docker-in-VM)</title>
      <link>https://www.pusnow.com/note/dinv/</link>
      <pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/dinv/</guid>
      <description>Source code available 간혹 Docker를 Docker 컨테이너 안에서 실행시켜야 하는 경우가 있다. 특히, CI 서비스(Jenkins Docker, GitHub Docker Container Action, GitLab Docker executor)를 Docker를 통하여 배포할 때, Docker 이미지를 빌드할 수 없는 문제가 생긴다. 이는 Docker 이미지를 빌드하기 위해 필요한 dockerd 데몬이 많은 시스템 권한을 요구하기 때문이다.
기존 솔루션 지금까지 dockerd를 컨테이너 안에서 실행시키기 위해서는 DooD (Docker-out-of-Docker) 혹은 DinD (Docker-in-Docker) 기법을 사용한다. DooD 기법은 컨테이너 내부에서 호스트 dockerd에 연결하여 사용하는 기법으로, 이를 위해 도커 컨트롤 소켓(/var/run/docker.</description>
    </item>
    
    <item>
      <title>비트 스캔 연산자의 Undefined Behavior</title>
      <link>https://www.pusnow.com/note/undefined-behaviors-of-bit-scan-operators/</link>
      <pubDate>Sun, 07 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/undefined-behaviors-of-bit-scan-operators/</guid>
      <description>비트 스캔 연산자에는 프로그래머가 주의를 기울이지 않으면 실수 할 수 있는 undefined behavior가 존재한다. 이 문서에서는 이런 undefined behavior와 이에 따른 버그 및 해결 방안을 알아본다.
비트 스캔 연산자 최신 프로세서에는 비트 스캔 연산자가 존재한다. Intel 프로세서의 경우 bsf (Bit Scan First), bsr (Bit Scan Reverse) 연산자와 BMI1 확장을 지원한다면 lzcnt (Leading Zero Count), tzcnt (Trailing Zero Count) 연산자가 추가로 존재한다. 이 연산자들은 기본적으로 피연산자를 스캔하여 가장 첫 번째 혹은 마지막 비트의 위치를 추출하는 역할을 한다.</description>
    </item>
    
    <item>
      <title>C Atomic Instruction Mapping</title>
      <link>https://www.pusnow.com/note/c-atomic-instruction-mapping/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/c-atomic-instruction-mapping/</guid>
      <description>Note Only 64 bits data types Compiler: clang 11.0.1 https://godbolt.org/z/drMsxvGd4 Mapping Table Operation x86-64 armv8-a RISC-V rv64gc Load (no atomic) mov rax, qword ptr [rip + y] adrp x8, yldr x0, [x8, :lo12:y] lui a0, %hi(y)ld a0, %lo(y)(a0) Load (implicit) mov rax, qword ptr [rip + x] adrp x8, xadd x8, x8, :lo12:xldar x0, [x8] fence rw, rwlui a0, %hi(x)ld a0, %lo(x)(a0)fence r, rw Load (relaxed) mov rax, qword ptr [rip + x] adrp x8, xldr x0, [x8, :lo12:x] lui a0, %hi(x)ld a0, %lo(x)(a0) Load (consume) mov rax, qword ptr [rip + x] adrp x8, xadd x8, x8, :lo12:xldar x0, [x8] lui a0, %hi(x)ld a0, %lo(x)(a0)fence r, rw Load (acquire) mov rax, qword ptr [rip + x] adrp x8, xadd x8, x8, :lo12:xldar x0, [x8] lui a0, %hi(x)ld a0, %lo(x)(a0)fence r, rw Load (release) Watomic-memory-ordering Watomic-memory-ordering Watomic-memory-ordering Load (acq_rel) Watomic-memory-ordering Watomic-memory-ordering Watomic-memory-ordering Load (seq_cst) mov rax, qword ptr [rip + x] adrp x8, xadd x8, x8, :lo12:xldar x0, [x8] fence rw, rwlui a0, %hi(x)ld a0, %lo(x)(a0)fence r, rw Store (no atomic) mov qword ptr [rip + y], rdi adrp x8, ystr x0, [x8, :lo12:y] lui a1, %hi(y)sd a0, %lo(y)(a1) Store (implicit) xchg qword ptr [rip + x], rdi adrp x8, xadd x8, x8, :lo12:xstlr x0, [x8] fence rw, wlui a1, %hi(x)sd a0, %lo(x)(a1) Store (relaxed) mov qword ptr [rip + x], rdi adrp x8, xstr x0, [x8, :lo12:x] lui a1, %hi(x)sd a0, %lo(x)(a1) Store (consume) Watomic-memory-ordering Watomic-memory-ordering Watomic-memory-ordering Store (acquire) Watomic-memory-ordering Watomic-memory-ordering Watomic-memory-ordering Store (release) mov qword ptr [rip + x], rdi adrp x8, xadd x8, x8, :lo12:xstlr x0, [x8] fence rw, wlui a1, %hi(x)sd a0, %lo(x)(a1) Store (acq_rel) Watomic-memory-ordering Watomic-memory-ordering Watomic-memory-ordering Store (seq_cst) xchg qword ptr [rip + x], rdi adrp x8, xadd x8, x8, :lo12:xstlr x0, [x8] fence rw, wlui a1, %hi(x)sd a0, %lo(x)(a1) Exchange (implicit) mov eax, 42xchg qword ptr [rip + x], rax adrp x8, x add x8, x8, :lo12:x mov w9, #42.</description>
    </item>
    
    <item>
      <title>파일시스템의 종류 - 로컬, 네트워크, 분산</title>
      <link>https://www.pusnow.com/note/distributed-file-system/</link>
      <pubDate>Mon, 07 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/distributed-file-system/</guid>
      <description>Ceph dissertation (Ceph: Reliable, Scalable, and High-performance Distributed Storage, 2007)의 Related Work 부분을 요약 정리하였다. 당시에는 SSD가 대중화되어있지 않아서, 이 dissertation에서 다루는 디스크는 대부분 하드 디스크이다.
파일시스템의 분류 파일시스템은 크게 세 가지로 분류된다.
로컬 파일시스템: 로컬에 장착된 디스크와 상호 작용 네트워크 파일시스템 (클라이언트-서버 파일시스템): 원격 서버와 상호 작용 분산 파일시스템: 파일시스템의 데이터가 여러 호스트로 분산 로컬 파일시스템 수십 년간 파일시스템은 Unix 파일시스템과 BSD 유닉스의 Fast 파일시스템 (Fast File System, FFS)에 크게 영향을 받아왔다.</description>
    </item>
    
    <item>
      <title>Size of Standard Types</title>
      <link>https://www.pusnow.com/note/size-of-standard-types/</link>
      <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/size-of-standard-types/</guid>
      <description>Table Types x86_64 (Linux) x86_64 (Windows) x86_64 (macOS) i386 (Linux) i386 (Windows) aarch64 (Linux) aarch64 (macOS) riscv64 (Linux) short 2 2 2 2 2 2 2 2 int 4 4 4 4 4 4 4 4 long 8 4 8 4 4 8 8 8 long long 8 8 8 8 8 8 8 8 float 4 4 4 4 4 4 4 4 double 8 8 8 8 8 8 8 8 long double 16 8 16 12 8 16 8 16 void* 8 8 8 4 4 8 8 8 size_t 8 8 8 4 4 8 8 8 Compilers Windows: Visual Studio 2019 macOS: Apple Clang 12/13 Linux: GCC 8 Source Code #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>Accelerating Disaggregated Data Centers Using Unikernel</title>
      <link>https://www.pusnow.com/publication/ddc-unikernel/</link>
      <pubDate>Tue, 11 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/publication/ddc-unikernel/</guid>
      <description>Wonsup Yoon, Jinyoung Oh, Sue Moon, and Youngjin Kwon
Proceedings of the ACM SIGCOMM 2020 Conference Posters and Demos (SIGCOMM &amp;lsquo;20 Posters and Demos)
Abstract Memory disaggregation is a new hardware and system paradigm to split computation and memory into physical separate nodes. Grouping and pooling hardware resources solves the low resource utilization problem and hide intermittent hardware failures in data centers. In this work we propose a unikernel-based remote paging for memory disaggregation.</description>
    </item>
    
    <item>
      <title>한글과 유니코드</title>
      <link>https://www.pusnow.com/note/hangul-and-unicode/</link>
      <pubDate>Mon, 04 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/note/hangul-and-unicode/</guid>
      <description>유니코드에서 한글을 어떻게 다루는지를 정리하였다.
유니코드 유니코드(Unicode)는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준 1 단순히 문자마다 번호를 붙임 계속 업데이트되며 현재는 Unicode Version 14.0.0 이 최신 UTF 유니코드를 실제 파일 등에 어떻게 기록할 것인지를 표준화한 것이다. 유니코드는 문자를 각 숫자에 대응시킨 것에 불과하고 이를 실제 비트로 표현하는 방식은 다양하다 UTF-8, UTF-16 등이 있다. 유니코드 속의 한글 Unicode Consortium의 Version 9.0.0 데이터베이스에 따르면 유니코드에서 한글이 지정된 블록은 다음과 같다.</description>
    </item>
    
    <item>
      <title>Wonsup Yoon</title>
      <link>https://www.pusnow.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://www.pusnow.com/about/</guid>
      <description>Research Interests Virtualization: unikernels, microVM, containers, etc. Networking: RDMA, virtio, etc. Datacenter: resource disaggregation, microservices, etc. Education Ph.D. Candidate in Computer Science, KAIST, 2019.9-present. GPA: 4.01/4.30 M.S. in Computer Science, KAIST, 2017.9-2019.8. GPA: 3.95/4.30 B.S. in Electrical and Electronic Engineering, Yonsei University, 2013.3-2017.2. Minor: Computer Science Graduation with High Honors (Top 3%) GPA: 4.01/4.30 Sunrin Internet High School, 2009.3-2012.2. Major: Information Communication Graduation with Highest Honors (Principal&amp;rsquo;s Award) Publications DiLOS: Do Not Trade Compatibility for Performance in Memory Disaggregation Wonsup Yoon, Jisu Ok, Jinyoung Oh, Sue Moon, and Youngjin Kwon Proceedings of the Eighteenth European Conference on Computer Systems (EuroSys), 2022.</description>
    </item>
    
  </channel>
</rss>
